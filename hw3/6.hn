/* This is a Horn file that will allow you to test your solution.  */

/* Use 'make' with the Makefile in this directory to convert this
 * file to C++ (using Horn) and then compile it to
 * produce class executable file 6.  The command
 *   ./6
 * will then read lines from the standard input (one boolean
 * expression per line) and print out whether it is true. 
 * The command
 *   ./6 FILE
 * does the same, but takes input from FILE. */

/* Operator precedence and associativity, listed from lowest to highest. 
 * These declarations will resolve conflicts such as ``if we've 
 * recognized e*e in the input and the next symbol is "+", should we
 * assume that (1) e*e came from the production e->e*e, or should we 
 * assume that (2) the second 'e' is going to be part of a later e+e?'' 
 * If * has higher precedence that + (is listed after + in the declarations 
 * below), then the answer is (1), and otherwise (2).  For a situation
 * of equal precendence, such as seeing e+e when the next symbol is +, 
 * we can choose to group the initial e+e together---indicated by %left---
 * or group as if the input were e+(e+e)---indicated by %right. */

%left '+'
%left '*'
%left '-'

%define error_function Error

%{
  static int Error (const char*, const char*);
%}

%%

/* Insert rules after this comment and before the next %% below.  Yacc and 
 * its progeny use ':' to mean "produces", '|' to mean "or" (as usual), 
 * and ';' to mark the end of a rule. For example:

	s : '0' '1' | '1' s '0' ;

 * or, as it is usually laid out:

	s : '0' '1' 
          | '1' s '0' 
          ;

 * The first non-terminal symbol listed to the left of a ':' is the start
 * symbol. 
 */

/* REPLACE THE RULE BELOW WITH YOUR SOLUTION (ONE OR MORE RULES) */

true : '1'
     ;

/* LEXICAL RULES (you don't have to touch these) */

*: ' ' | '\t' | '\n' | '\r' ;

%%

#include <cctype>
#include <iostream>
#include <string>

using namespace std;

/* The following program reads boolean expressions written one per line
 * on the standard input, and then reprints them, indicating which are
 * accepted by the grammar above. */
int
main ()
{
    while (true) {
	string input;
	getline (cin, input);
	if (cin.eof ())
	    return 0;
	if (input.find_last_not_of (' ') == input.npos)
	    continue;
	yylex_init ();
	yypush_lexer (input, "?");
	if (yyparse () == 0)
	    cout << "\"" << input <<  "\" is true." << endl;
	else
	    cout << "\"" << input << "\" is false." << endl;
    }
}

int
Error (const char*, const char* msg) {
    cerr << msg << endl;
    return 0;
}
